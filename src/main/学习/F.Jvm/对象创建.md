# Table of Contents

* [虚拟机如何分配对象内存](#虚拟机如何分配对象内存)
* [CAS](#cas)
* [TLAB](#tlab)


# 虚拟机如何分配对象内存

虚拟机遇到一条new指令时，先检查运行时常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。（当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞。而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]
就只能采用较为复杂的空闲列表来分配内存。）

为对象分配内存

· 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。

· 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

**在并发场景中，如何内存分配过程的线程安全性？如果两个线程先后把对象引用指向了同一个内存区域，怎么办。**

一般有两种解决方案：

- 1、对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。
- 2、每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配，当这部分区域用完之后，再分配新的"私有"内存。

# CAS

# TLAB

TLAB是线程的一块**私有内存**，它是虚拟机在**堆内存的eden**划分出来的，如果设置了虚拟机参数 `-XX:UseTLAB`,在线程初始化时，同时也会申请一块指定大小的内存， 只给当前线程使用，
这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。

**TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已，当一个TLAB用满 ，就会新申请一个TLAB。**
