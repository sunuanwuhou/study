# Table of Contents

* [消息队列作用](#消息队列作用)
  * [解耦](#解耦)
  * [最终一致性](#最终一致性)
  * [广播](#广播)
  * [错峰与流控](#错峰与流控)
* [如何设计一个消息队列](#如何设计一个消息队列)
* [消息队列基本功能](#消息队列基本功能)
  * [RPC通信协议](#rpc通信协议)
  * [高可用](#高可用)
  * [服务端承载消息堆积的能力](#服务端承载消息堆积的能力)
  * [消费关系解析](#消费关系解析)
  * [消费确认](#消费确认)
  * [重复消息和顺序消息](#重复消息和顺序消息)
* [参考资料](#参考资料)




​		这篇文章为什么要放在第一篇呢？从我个人理解，了解一项技术，我们要先了解此技术为什么出现，可以解决什么问题、本身具体怎样的特性，才能去解决对应的业务场景。

# 消息队列作用



## 解耦

解耦是消息队列要解决的**最本质问题**。

所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其他系统但不那么重要的事情，有通知即可，无需等待结果。

**换句话说，基于消息的模型，关心的是“通知”，而非“处理”。** 

+ 举列

对于我们的订单系统，订单最终支付成功之后可能需要给用户发送短信积分什么的，但其实这已经不是我们系统的核心流程了。如果外部系统速度偏慢（比如短信网关速度不好），那么主流程的时间会加长很多，用户肯定不希望点击支付过好几分钟才看到结果。那么我们只需要通知短信系统“我们支付成功了”，不一定非要等待它处理完成。



## 最终一致性

最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。

当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的

+ 举列

现实A给B转账100,B要收到100。

[具体可以看分布式事务](../分布式事务.md)



## 广播



消息队列的**基本功能之一是进行广播**。


如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。



## 错峰与流控



试想上下游对于事情的处理能力是不同的。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。

 当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。 如果下游有很多系统关心你的系统发出的通知的时候，果断地使用消息队列吧。




# 如何设计一个消息队列



> 最简 单的消息队列可以做成一个消息转发器，把一次RPC做成两次RPC。发送者把消息投递到服务端（以下简称broker），服务端再将消息转发一手到接收端，就是这么简单。


基本思路：

1. producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等
2. 利用RPC将数据流串起来
3. 然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。
4. 如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。
5. 为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。



 在完成了上述几个功能后，消息队列基本就实现了。然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。





# 消息队列基本功能



## RPC通信协议

刚才讲到，所谓消息队列，无外乎两次RPC加一次转储，当然需要消费端最终做消费确认的情况是三次RPC。既然是RPC，就必然牵扯出一系列话题，什么负载均衡啊、服务发现啊、通信协议啊、序列化协议啊，等等。在这一块，我的强烈建议是不要重复造轮子。



## 高可用

而消息队列的高可用，只要保证broker接受消息和确认消息的接口是幂等的，并且consumer的几台机器处理消息是幂等的，这样就把消息队列的可用性，转交给RPC框架来处理了。

## 服务端承载消息堆积的能力



消息到达服务端如果不经过任何处理就到接收者了，broker就失去了它的意义。

为了满足我们错峰/流控/最终可达等一系列需求，把消息存储下来，然后**选择时机投递**就显得是顺理成章的了。



## 消费关系解析

现在我们的消息队列初步具备了转储消息的能力。下面一个重要的事情就是解析发送接收关系，进行正确的消息投递了。 市面上的消息队列定义了一堆让人晕头转向的名词，如JMS 规范中的Topic/Queue，Kafka里面的Topic/Partition/ConsumerGroup，RabbitMQ里面的Exchange等等。抛开现象看本质，无外乎是单播与广播的区别。所谓单播，就是点到点；而广播，是一点对多点。当然，对于互联网的大部分应用来说，组间广播、组内单播是最常见的情形。 消息需要通知到多个业务集群，而一个业务集群内有很多台机器，只要一台机器消费这个消息就可以了。 当然这不是绝对的，很多时候组内的广播也是有适用场景的，如本地缓存的更新等等。另外，消费关系除了组内组间，可能会有多级树状关系。这种情况太过于复杂，一般不列入考虑范围。所以，一般比较通用的设计是支持组间广播，不同的组注册不同的订阅。组内的不同机器，如果注册一个相同的ID，则单播；如果注册不同的ID(如IP地址+端口)，则广播。 至于广播关系的维护，一般由于消息队列本身都是集群，所以都维护在公共存储上，如config server、zookeeper等。维护广播关系所要做的事情基本是一致的:

1. 发送关系的维护。
2. 发送关系变更时的通知。



## 消费确认



## 重复消息和顺序消息



丢失消息是不能忍受的，重复消息是可以处理的





# 参考资料

https://tech.meituan.com/2016/07/01/mq-design.html

