# Table of Contents

* [一、查询条件包含or，可能导致索引失效](#一查询条件包含or可能导致索引失效)
* [二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效](#二如何字段类型是字符串where时一定用引号括起来否则索引失效)
* [三、like通配符可能导致索引失效。](#三like通配符可能导致索引失效)
* [使用mysql的内置函数，索引失效。](#使用mysql的内置函数索引失效)
* [隐式字符编码转换](#隐式字符编码转换)
* [隐式类型转换](#隐式类型转换)
* [参考资料](#参考资料)






最近生产爆出一条慢sql，原因是用了or和!=，导致索引失效。于是，总结了索引失效的十大杂症

# 一、查询条件包含or，可能导致索引失效



1. select * from t where a=xx or b=xx，a和b分别建立了索引，问，会不会走索引

   > 会

2. select * from t where a=xx or b=xx，a索引 b普通字段，问，会不会走索引

   >  不会  
   >
   > 1. 走索引A
   > 2. 全表扫描b
   > 3. 合并
   >
   > mysql会优化为全表扫描





# 二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效

userId为字符串类型，**是B+树的普通索引**，如果查询条件传了一个数字过去，它是不走索引的



# 三、like通配符可能导致索引失效。

并不是用了like通配符，索引一定失效，而是like查询是以%开头，才会导致索引失效。

```mysql
'%a'     //以a结尾的数据
'a%'     //以a开头的数据
'%a%'    //含有a的数据
'_a_'    //三位且中间字母是a的
'_a'     //两位且结尾字母是a的
'a_'     //两位且开头字母是a的
```


like查询是以%开头的，**也可以使用覆盖索引进行优化**

# 使用mysql的内置函数，索引失效。
# 隐式字符编码转换
# 隐式类型转换

```mysql
mysql> select * from tradelog where tradeid=110717;
```

对于优化器来说，这个语句相当于：

```mysql
mysql> select * from tradelog where CAST(tradid AS signed int) = 110717;
```

也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走
树搜索功能。







# 参考资料

[12222222](https://github.com/whx123/JavaHome/blob/master/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9D%82%E7%97%87.md#%E4%B8%80%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E5%8C%85%E5%90%ABor%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88）

