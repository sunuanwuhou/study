在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通 索引的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一 索引？

假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不 会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的 SQL语句： 所以，你一定会考虑在id_card字段上建索引。

由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么 给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重 复的身份证号，那么这两个选择逻辑上都是正确的。

现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什 么呢？

```mysql
 select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';
```

所以，你一定会考虑在id_card字段上建索引。 由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么
给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。

现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什 么呢？

接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。

# 查询语句

假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过 程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然 后可以认为数据页内部通过二分法来定位记录。

+ 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到 碰到第一个不满足k=5条件的记录。
+ 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止 继续检索。

**那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。**

你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB 中，每个数据页的大小默认是16KB。

因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里 了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需 要一次指针寻找和一次计算。

当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取 下一个数据页，这个操作会稍微复杂一些。

但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来 说可以忽略不计。



# 更新语句


更新还是有区别的，详情请见：[ChangeBuffer](ChangeBuffer.md)



# 总结

1. 普通索引和唯一索引，在查询语句没有太大的性能变化

2. 但是更新语句上，
   + 如果写多读少，那么就不要用唯一索引
   + 如果读多写少，可以用。