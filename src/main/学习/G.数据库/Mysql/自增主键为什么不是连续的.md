# Table of Contents

* [自增值保存在哪里](#自增值保存在哪里)
* [自增值修改机制(了解)](#自增值修改机制了解)
* [不连续原因](#不连续原因)
  * [唯一键冲突或者回滚，自增值不回滚。](#唯一键冲突或者回滚自增值不回滚)
  * [自增主键的批量申请](#自增主键的批量申请)


 先说一个总结：**主键ID是是连续的，但不是递增的。**

# 自增值保存在哪里

+ 5.7版本：保存在内存里，重启后，回去表中找到max(id),然后max(id)+1作为当前表的自增值。

  > 举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11。这时 候，我们删除id=10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后 这个表的AUTO_INCREMENT就会变成10。

+ 8.0版本：将自增值保存在redo log中，重启的依靠redo log来恢复。

# 自增值修改机制(了解)

假设，某次要插入的值是X，当前的自增值是Y。

1. 如果X<Y，那么这个表的自增值不变；

2. 如果X≥Y，就需要把当前自增值修改为新的自增值

**新的自增值生成算法是**：从auto_increment_offset开始，以auto_increment_increment为 步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。

# 不连续原因

## 唯一键冲突或者回滚，自增值不回滚。

你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去 呢？

其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看自 增值为什么不能回退。

假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id， 肯定要加锁，然后顺序申请。

1. 假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执 行。 
2.  事务B正确提交了，但事务A出现了唯一键冲突。 
3. 如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情 况：表里面已经有id=3的行，而当前的自增id值是2。 
4. 接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入 语句报错“主键冲突”。 而为了解决这个主键冲突，

有两种方法：

1. 每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这 个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判 断id是否存在。 insert into t values(null,1,1); begin; insert into t values(null,2,2); rollback; insert into t values(null,2,2); //插入的行是(3,2,2) 
2.  把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。 可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允 许自增id回退”的前提导致的。 

**因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只 保证了自增id是递增的，但不保证是连续的**

> 总结就是：因为事务的回滚机制，会导致申请的id不可用，如果要解决id连续递增，会带来性能问题。
>
> 深层次原因是，不判断自增主键是否已存在和减少加锁的时间范围和粒度->为了更高的性能- >自增主键不能回退->自增主键不连续



## 自增主键的批量申请

