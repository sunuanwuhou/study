1. 表的自增id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲
   突的错误。

2. row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写的数据会覆盖之
   前的数据。

3.  Xid只需要不在同一个binlog文件中出现重复值即可。虽然理论上会出现重复值，但是概率
   极小，可以忽略不计。

4.  InnoDB的max_trx_id 递增值每次MySQL重启都会被保存起来，所以我们文章中提到的脏
   读的例子就是一个必现的bug。

5.  thread_id是我们使用中最常见的，而且也是处理得最好的一个自增id逻辑了。  

   ```java
   do {
   new_id= thread_id_counter++;
   } while (!thread_ids.insert_unique(new_id).second);
   ```

   



# 疑惑

既然自定义主键id和row_id都会用完，那么怎么设计避免业务出现问题？

> 按理来说 还没用完，数据量这么多 就要做分表了 
>
> 如果是在刚的话，那就自己定义一个varchar，自己慢慢加。
>
> 业务上要尽量避免用id来做业务关联.





