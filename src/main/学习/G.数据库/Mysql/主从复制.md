# Table of Contents

* [主从模式部署分为哪几种](#主从模式部署分为哪几种)
* [主从节点如何保持数据一致](#主从节点如何保持数据一致)
* [如何进行主从复制(重点)](#如何进行主从复制重点)
* [主从延迟](#主从延迟)
  * [主从延迟原因](#主从延迟原因)
* [主从复制有哪几种模式](#主从复制有哪几种模式)
* [强同步模式(重点TDSQL)](#强同步模式重点tdsql)
* [读写分离的坑](#读写分离的坑)
  * [**读写分离的场景下,怎么保证从数据库读到最新的数据?**](#读写分离的场景下怎么保证从数据库读到最新的数据)
    * [强制走主库方案](#强制走主库方案)
    * [缓存标记法。](#缓存标记法)
    * [sleep方案](#sleep方案)
    * [判断主备是否有延迟](#判断主备是否有延迟)
* [参考资料](#参考资料)




> 最开始以为Mysql和Redis主从是差不多。
>
> 后面细看还是有个别区别。
>
> 1.



# 主从模式部署分为哪几种

+ 一主一丛

+ 一主多从

+ 级联多从：其实就是主的代理，这种分担了主的压力。

  ![image-20211128200551999](.images/image-20211128200551999.png)



# 主从节点如何保持数据一致

+ 双写DB：成本比较大，保持一致性。
+ 主从复制：一般都是主从。





# 如何进行主从复制(重点)


当主节点上进行写操作时，会按照时间先后顺序写入到binlog中。**主从复制就是基于binlog**进行的，具体流程有两部分。

+ 当从节点连接到主节点时，主节点会创建一个叫做dump的线程，**有多少个从节点，就会创建多少个dump线程**;

  > 节点多也会带来开销，一般好像都是一主2从。

+ 当主节点的binlog发生变化的时候，dump线程就会通知从节点，并将相应的binlog内容发送给从节点。

当开启主从同步的时候，**从节点会创建两个线程用来完成数据同步工作**

+ **I/O线程**连接到主节点，主节点上的dump线程会将binlog的内容发送给I/O线程。它接收到内容后，再将其写入到本地的relay log。

+ **SQL线程**读取I/O线程写入的relay log，并且根据relay log的内容对从数据库做对应的操作。



![](.images/下载-1638101633468.png)



> 这里要注意几个点
>
> 1. M上的dump线程，S上的Io线程和sql线程。
> 2. dump读取的binlog，是page cache还是disk？在哪里就读哪里的。



# 主从延迟

与数据同步有关的时间点主要包括以下三个：
1. 主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;
2. 之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;
3. 备库B执行完成这个事务，我们把这个时刻记为T3。

所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。



你可以在备库上执行`show slave status`命令，它的返回结果里面会显示`seconds_behind_master`，用于表示当前备库延迟了多少**秒**。

seconds_behind_master的计算方法是这样的：
1. 每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；
2. 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到
seconds_behind_master。

可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用
seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。

你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？其实不会的。

因为，备库连接到主库的时候，会通过执行`SELECT UNIX_TIMESTAMP()`函数来**获得当前主库的系统时间**。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。



需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。

所以说，主备延迟最直接的表现是，**备库消费中转日志（relay log）的速度，比主库生产**
**binlog的速度要慢。**接下来，我就和你一起分析下，这可能是由哪些原因导致的。



## 主从延迟原因

+ 备库所在机器的性能要比主库所在的机器性能差。
+ 备库的压力大。
+ 大事务。







# 主从复制有哪几种模式

+ 异步模式：这种模式下，主节点不关心dump线程同步情况，直接返回成功给客户。

+ 半同步模式：主节点只需要接收到**其中一台从节点**的返回信息，就会给用户返回成功，否则需要等待直到超时回滚。

  > 超时回滚，当前主库事务回滚吗？

+ 全同步模式：指主节点和从节点全部执行并**提交**了，才会向客户端返回成功。

  ​	**注意，是提交，而不只是从节点写入到relay log**，这样主从是强一致性的，但性能损耗非常大，必须在网络良好的情况下使用。

![](.images/下载-1638102059147.png)



# 强同步模式(重点TDSQL)

全同步主要性能损耗在**于同步等待返回**，业界有一个方案叫MAR，即异步多线程强同步复制，只有当备机数据完全同步后，才由主机给予应用事务应答，保障数据不丢失，同时还用多线程思路保证了性能。

MAR可以说是半同步和全同步的折中，经常被称为强同步。腾讯的明星产品TDSQL，就是使用的MAR做同步。



+ Master上事务**写到binlog就算结束**，将会话保存到session中。接着**执行下一轮循环去处理其它请求**，这样就避免让线程阻塞等待应答了。
+ 然后负责主备同步的dump线程会将binlog立即发送给slave，slave的IO线程收到binlog并写入到relay log之后，**再给主机一个应答。**
+ 在Master，会有一组线程来处理应答，收到应答之后找到对应的会话，**还可以批量执行commit，并且给客户端应答。**

> 强同步只是提升了系统的并发能力，但是对于事务处理能力是没有提高的。



![](.images/下载-1638102530895.png)

综合来看，MAR强同步复制的特点保证了节点间数据的较强一致性，又将串行同步操作异步化，还引入线程池能力，保证同城情况下TPS几乎不会下降。





# 读写分离的坑

读写分离的主要目标就是分摊主库的压力。

+ 客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，**由客户端来选择后端数据库进行查询。**
+ 还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。





## **读写分离的场景下,怎么保证从数据库读到最新的数据?**

### 强制走主库方案

对于更新完需要立即读取数据的，只能强制走主库。

### 缓存标记法。

在高并发场景或者网络不佳的场景，如果存在较大的主从同步数据延迟，这时候读请求去读从库，就会读到旧数据。这时候最简单暴力的方法，就是**强制读主库**。实际上可以使用**缓存标记法**。

![image-20220421201741721](.images/image-20220421201741721.png)

- A发起写请求，更新主库数据，并在缓存中设置一个标记，表示数据已更新，标记格式为：userId+业务Id。
- 设置此标记，**设置过期时间（估值为主库和从库同步延迟的时间）**
- B发起读请求，先判断此请求，在缓存中有没有更新标记。
- 如果存在标记，走主库；如果没有，请求走从库。

这个方案，解决了数据不一致问题，但是每次请求都要先跟缓存打交道，会影响系统吞吐



### sleep方案

+ 业务：可以做一个临时页面。像支付宝这样。在临时页面点击完成。再去获取数据。
+ 技术：这个其实就是在查询从库的时候，sleep



### 判断主备是否有延迟

+ 第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断`seconds_behind_master`是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。

+ 第二种方法，对比位点确保主备无延迟：
+ 第三种方法，对比GTID集合确保主备无延迟：



# 参考资料

https://mp.weixin.qq.com/s/426oD3DMoDhsesHcZ52fwA

https://mp.weixin.qq.com/s/qhsVURhXm0Ot-jWq0khfEg
