# Table of Contents

* [在读缓冲池中](#在读缓冲池中)
* [不在读缓冲池中](#不在读缓冲池中)
* [**写缓冲**](#写缓冲)
* [**InnoDB加入写缓冲优化，上文“不在读缓冲池”流程会有什么变化？**](#innodb加入写缓冲优化上文不在读缓冲池流程会有什么变化)
* [**写缓冲是否会出现一致性问题呢？**](#写缓冲是否会出现一致性问题呢)
* [**写缓冲优化，为什么适用于非唯一普通索引页**](#写缓冲优化为什么适用于非唯一普通索引页)
* [总结](#总结)
* [参考资料](#参考资料)










 对于读请求，buffer-pool缓冲池能够减少磁盘IO，提升性能。问题来了，**那写请求呢？** 

修改数据有2种情况

+ 在读缓冲池中
+ 不在读缓冲池中



# 	在读缓冲池中

 假如要修改页号为4的索引页，而这个页正好在缓冲池内。 

（1）直接修改缓冲池中的页，一次内存操作；

（2）写入redo log，一次磁盘顺序写操作；

这样的效率是最高的。

> 像写日志这种顺序写，每秒几万次没问题。
> 

+ **是否会出现一致性问题呢？**

并不会。

（1）读取，会命中缓冲池的页；

（2）缓冲池LRU数据淘汰，会将“脏页”刷回磁盘；

（3）数据库异常奔溃，能够从redo log中恢复数据；

+ **什么时候缓冲池中的页，会刷到磁盘上呢？**

定期刷磁盘，而不是每次刷磁盘，能够降低磁盘IO，提升MySQL的性能。

*画外音：批量写，是常见的\*优化\*手段。*



# 不在读缓冲池中

 假如要修改页号为40的索引页，而这个页正好**不**在缓冲池内。 

此时麻烦一点，如上图需要1-3：

（1）先把需要为40的索引页，从磁盘加载到缓冲池，一次磁盘随机读操作；

（2）修改缓冲池中的页，一次内存操作；

（3）写入redo log，一次磁盘顺序写操作；

没有命中缓冲池的时候，**至少产生一次磁盘IO**，对于写多读少的业务场景，**是否还有优化的空间呢？**

> 如果一条数据，产生一次IO到还好，可以现实中写的数据量也是很大的，每次都产生IO,效率自然就很低了。





#  **写缓冲**(change buffer)

在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)。

 

它是一种应用在**非唯一普通索引页**(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到**读缓冲池**，而仅仅记录缓冲变更(buffer changes)，等**未来数据被读取/定时合并**时，再将数据合并(merge)恢复到读缓冲池中的技术。写缓冲的**目的**是降低写操作的磁盘IO，提升数据库性能



> 1. change buffer也是在bufferpool中的，可以通过参数设置。
> 2. 把change buffer应用到旧的数据页，得到新的数据页的过程称为merge。除了访问这个
>    数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的
>    过程中，也会执行merge操作。
> 3. 虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，
>    change buffer在内存中有拷贝，也会被写入到磁盘上。



#  **InnoDB加入写缓冲优化，上文“不在读缓冲池”流程会有什么变化？** 

 假如要修改页号为40的索引页，而这个页正好**不**在缓冲池内。 

加入**写缓冲**优化后，流程优化为：

（1）在写缓冲中记录这个操作，一次内存操作；

（2）写入redo log，一次磁盘顺序写操作；

# **写缓冲是否会出现一致性问题呢？**

也不会。

（1）数据库异常奔溃，能够从**redo log**中恢复数据；

（2）写缓冲不只是一个内存结构，它也会被**定期刷盘(merge)**到写缓冲系统表空间；

（3）数据读取时，有另外的流程，将数据合并到缓冲池；

> ​	如果还没有merge，读取数据的时候会强行merge

 

+ 不妨设，稍后的一个时间，有请求查询索引页40的数据。

  此时的流程如序号1-3：

  （1）载入索引页，缓冲池未命中，这次磁盘IO不可避免；

  （2）从写缓冲读取相关信息；

  （3）恢复索引页，放到缓冲池LRU里；

  *画外音：可以看到，40这一页，在真正被读取时，才会被加载到缓冲池中。*

   

#  **写缓冲优化，为什么适用于非唯一普通索引页** 

如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免(否则怎么校验是否唯一？)，此时就应该直接把相应的页放入缓冲池再进行修改，而不应该再整写缓冲这个幺蛾子。

 

# changer buffer 场景

因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时changebuffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。





# 总结

1. 修改的数据，可能在buffer pool中，也可能不再。
2. 不在bufferpool中修改的数据，每次会多一次随机读取IO.
3. 为了提高效率，产生了写缓冲。写缓冲的**目的**是降低写操作的磁盘IO，提升数据库读性能
4. 写缓冲也会记录redo日志。
5. 写缓冲的数据，在下一次读取的时候/定时刷新，才会加载到buffer pool中。
6. 写缓冲适用于**非唯一普通索引**，唯一索引会有唯一性检查。
7. redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。



# 小疑惑

+ changebuffer跟普通数据页一样也是**存在磁盘里**，区别在于changebuffer是在共享表空
  间ibdata1里

+ 在change buffer中有此行记录的情况下，再次更改，是增加一条还是原地修改？

  > 增加

+ 对数据的修改记录在changebuffer里的时候，内存里是没有这个物理页的，不存在脏页，merge后才会后脏页产生。数据：磁盘->内存。

+ 真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的，而不是根据
  redolog



# 参考资料



+ https://mp.weixin.qq.com/s/OMntrDZsrDL29UhC4_DSBQ
+ Mysql45讲 