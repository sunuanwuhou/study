# Table of Contents

  * [行锁 `Record lock `](#行锁-record-lock-)
  * [间隙锁`Gap Locks`](#间隙锁gap-locks)
  * [Next-Key Locks](#next-key-locks)
  * [插入意向锁LOCK_INSERT_INTENTION](#插入意向锁lock_insert_intention)
  * [隐式锁](#隐式锁)
* [怎么减少行锁对性能的影响？](#怎么减少行锁对性能的影响)
  * [死锁检测](#死锁检测)
  * [怎么解决由这种热点行更新导致的性能问题呢？](#怎么解决由这种热点行更新导致的性能问题呢)
  * [小结](#小结)
* [如何查看事务加锁情况](#如何查看事务加锁情况)
  * [使用infomation_schema数据库中的表获取锁信息](#使用infomation_schema数据库中的表获取锁信息)
    * [**INNODB_TRX**](#innodb_trx)
    * [INNODB_LOCKS](#innodb_locks)
    * [INNODB_LOCK_WAITS](#innodb_lock_waits)
  * [使用show engine innodb status 命令(推荐)](#使用show-engine-innodb-status-命令推荐)
* [总结](#总结)



## 行锁 `Record lock `

> 典型特点是：开销比较大，加锁慢，可能会导致死锁，
>
> 开销大是指：因为锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。

+ 行锁主要加在索引上，如果对非索引的字段设置条件进行更新，行锁可能会变成表锁。
+ InnoDB的行锁是针对**索引加锁**，不是针对记录加锁，并且加锁的索引不能失效，否则行锁可能会变成表锁。

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

## 间隙锁`Gap Locks`

左开右开

锁定索引之间的间隙，但是不包含索引本身。开区间

![image-20210901144911219](.images/image-20210901144911219.png)

如图中为`number`值为`8`的记录加了`gap锁`，意味着**不允许别的事务在`number`值为`8`的记录前边的`间隙`插入新记录**，其实就是`number`列的值`(3, 8)`这个区间的新记录是不允许立即插入的。

> `gap锁`的作用仅仅是为了防止插入幻影记录的而已。


<font color=red>不知道大家发现了一个问题没，给一条记录加了`gap锁`只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是`hero`表中`number`值为`20`
的记录之后的间隙该咋办呢</font>

`数据页`时介绍的两条伪记录了：

- `Infimum`记录，表示该页面中最小的记录。
- `Supremum`记录，表示该页面中最大的记录。

为了实现阻止其他事务插入`number`值在`(20, +∞)`这个区间的新记录，我们可以给索引中的最后一条记录，也就是`number`值为`20`的那条记录所在页面的`Supremum`记录加上一个`gap锁`

<font color=red>这样就可以阻止其他事务插入`number`值在`(20, +∞)`这个区间的新记录。</font>

> Q:但是这也只是一个数据页，2个数据页呢？难道找到最后一个数据页的最大值？
>
> A:

## Next-Key Locks

左开右闭

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```java
(-∞,10]
        (10,11]
        (11,13]
        (13,20]
        (20,+∞)
```

> 注意这里是闭区间！

## 插入意向锁LOCK_INSERT_INTENTION

![image-20210901150703794](.images/image-20210901150703794.png)

## 隐式锁

一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于`事务id`这个牛逼的东东的存在，相当于加了一个`隐式锁`。

别的事务在对这条记录加`S锁`或者`X锁`时，由于`隐式锁`的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

- 情景一：对于聚簇索引记录来说，有一个`trx_id`隐藏列，该隐藏列记录着最后改动该记录的`事务id`。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的`trx_id`隐藏列代表的的就是当前事务的`事务id`
  ，如果其他事务此时想对该记录添加`S锁`或者`X锁`时，首先会看一下该记录的`trx_id`隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个`X锁`（也就是为当前事务创建一个锁结构，`is_waiting`
  属性是`false`），然后自己进入等待状态（**也就是为自己也创建一个锁结构**，`is_waiting`属性是`true`）。
- 情景二：对于二级索引记录来说，本身并没有`trx_id`隐藏列，但是在二级索引页面的`Page Header`部分有一个`PAGE_MAX_TRX_ID`属性，该属性代表对该页面做改动的最大的`事务id`
  ，如果`PAGE_MAX_TRX_ID`属性值小于当前最小的活跃`事务id`，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复`情景一`的做法。

# 怎么减少行锁对性能的影响？

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

知道了这个设定，对我们使用事务有什么帮助呢？**那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**我给你举个例子。

----

1. 从顾客A账户余额中扣除电影票价；
2. 给影院B的账户余额增加这张电影票价；
3. 记录一条交易日志。

也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？

**试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。**因为它们要更新同一个影院账户的余额，需要修改同一行数据。

根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。

这就最大程度地减少了事务之间的锁等待，提升了并发度。好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。

如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在 活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整 个数据库每秒就执行不到100个事务。这是什么原因呢？

这里，我就要说到死锁和死锁检测了。

## 死锁检测

当出现死锁以后，有两种策 略：

+ 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数
  innodb_lock_wait_timeout来设置。
+ 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他
  事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

 在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当 出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

 但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时 候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。

  所以，正常情况下我们还是要采用第二种策略，即：**主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。**主动死锁检测在发生死锁的时候，是能够快 速发现并进行处理的，但是它也是有额外负担的。



 你可以想象一下这个过程：**每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别**
**人锁住**，如此循环，最后判断是否出现了循环等待，也就是死锁。 那如果是我们上面说到的所有事务都要更新同一行的场景呢？

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。

---

老师，关于死锁检测innodb_deadlock_detect我想请教一下，是每条事务执行前都会进行检
测吗？如果是这样，即使简单的更新单个表的语句，当每秒的并发量达到上千的话，岂不是
也会消耗大量资源用于死锁检测吗？
作者回复 是个好问题
**如果他要加锁访问的行上有锁，他才要检测。**
这里面我担心你有两个误解，说明下：

1. 一致性读不会加锁，就不需要做死锁检测；
2. 并不是每次死锁检测都都要扫所有事务。比如某个时刻，事务等待状态是这样的：
B在等A，
D在等C，
现在来了一个E，发现E需要等D，那么E就判断跟D、C是否会形成死锁，这个检测不用管B和A



## 怎么解决由这种热点行更新导致的性能问题呢？

+ 1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用

+ 2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大 量的死锁检测工作了。

+ 3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。 innodb行级锁是通过锁**索引记录**实现的，如果更新的列没建索引是会锁住整个表的。

  

## 小结

+ 两阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释 放， 而是要等到事务结束时才释放。 建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量 往后放。
+ 死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源 时，就会导致这几个线程都进入无限等待的状态。
    + 解决方案： 1、通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎 默认值是50s。
    + 2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执 行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状 态）。
+ 如何解决热点行更新导致的性能问题？
    + 1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用
    + 2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大 量的死锁检测工作了。
    + 3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。 innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。

# 如何查看事务加锁情况

## 使用infomation_schema数据库中的表获取锁信息

`infomation_schema`数据库中，有几个表跟锁紧密关联的。

- **INNODB_TRX**：该表存储了InnoDB当前正在执行的事务信息，包括事务id、事务状态（比如事务是在运行还是在等待获取某个所）等。

- **INNODB_LOCKS**：该表记录了一些锁信息，包括两个方面：1.如果一个事务想要获取某个锁，但未获取到，则记录该锁信息。2. 如果一个事务获取到了某个锁，但是这个锁阻塞了别的事务，则记录该锁信息。

- **INNODB_LOCK_WAITS**:表明每个阻塞的事务是因为获取不到哪个事务持有的锁而阻塞。

### **INNODB_TRX**

```mysql
begin;
select  * from table limit  1 for update ;

 select *
 from information_schema.INNODB_TRX;
```

![image-20220506202618110](.images/image-20220506202618110.png)

表中可以看到一个事务id为`621317`正在运行汇中，它的隔离级别为`REPEATABLE READ`。我们一般关注这几个参数：

- trx_tables_locked：该事务当前加了多少个表级锁。
- trx_rows_locked：表示当前加了多少个行级锁。
- trx_lock_structs：表示该事务生成了多少个内存中的锁结构。

### INNODB_LOCKS

一般系统中，发生某个事务**因为获取不到锁而被阻塞时**，该表才会有记录。

事务A、B执行如下：

```mysql
//语句1  621319
begin;
select  * from km_site_meter where  site_id =1 limit  1 for update ;

//语句2 621323
begin;
update km_site_meter set meter_no='1' where  site_id=1

```

![image-20220506203244711](.images/image-20220506203244711.png)

**可以看到两个事务Id `621321`和`621319`都持有什么锁**，就是看那个`lock_mode和lock_type`哈。

但是并看不出是**哪个锁在等待那个锁导致的阻塞**，这时候就可以看`INNODB_LOCK_WAITS`表啦。

### INNODB_LOCK_WAITS

INNODB_LOCK_WAITS 表明每个事务是因为获取不到哪个事务持有的锁而阻塞。

![image-20220506203549554](.images/image-20220506203549554.png)

- requesting_trx_id：表示因为获取不到锁而被阻塞的事务的事务id
- blocking_trx_id：表示因为获取到别的事务需要的锁而导致其被阻塞的事务的事务Id。 **其实就是占用锁的事务**

## 使用show engine innodb status 命令(推荐)

**INNODB_LOCKS** 和 **INNODB_LOCK_WAITS** 在MySQL 8.0已被移除，其实就是不鼓励我们用这两个表来获取表信息。

而我们还可以用`show engine innodb status`获取当前系统各个事务的加锁信息。

```mysql
show engine innodb status
```

在看死锁日志的时候，我们一般先把这个变量`innodb_status_output_locks`打开哈，它是MySQL 5.6.16 引入的

一定要打开这个！！！!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```mysql
set global  innodb_status_output_locks =on;
```

![image-20220506205253612](.images/image-20220506205253612.png)

status有很多信息，我们主要关注`TRANSACTIONS`

![image-20220506205912183](.images/image-20220506205912183.png)

这结构锁的关键词需要记住一下哈：

- `lock_mode X locks gap before rec`表示X型的gap锁
- `lock_mode X locks rec but not gap`表示 X型的记录锁（Record Lock）
- `lock mode X` 一般表示 X型临键锁（next-key 锁）


- `TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED`表示它在等这个锁
- `RECORD LOCKS space id 267 page no 4 n bits 80 index c of table `test2`.`
  t5` trx id 1644853 lock_mode X locks gap before rec insert intention waiting`表示一个锁结构，这个锁结构的Space ID是267，page
  number是4，n_bits属性为80，对应的索引是`c`，这个锁结构中存放的锁类型是X型的插入意向Gap锁。

# 总结

这次我以 **MySQL 8.0.26** 版本做了几个实验，让大家了解了唯一索引和非唯一索引的行级锁的加锁规则。

这里需要注意的是，不同的版本加锁规则可能会有所不同。我这里总结下， 我这个 MySQL 版本的行级锁的加锁规则。

唯一索引等值查询：

- 当查询的记录是存在的，next-key lock 会退化成「记录锁」。
- 当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。

非唯一索引等值查询：

- 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
- 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：

- 唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。
- 非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。

这些加锁规则其实很好总结的，大家自己可以用我文中的案例测试一遍，看一下你的 MySQL 版本和我的 MySQL 版本的加锁规则有什么不同。

